from tkinter.ttk import Progressbar
import numpy as np
import qutip as qp

def matrix_exp_padé(A, p, q):
    """
    Approximation of matrix exponential of A using (p,q) Padé approximants.

    Parameters
    ----------
    A : array_like
        Square matrix.
    p : int
        Order of numerator of approximant.
    q : int
        Order of denominator of approximant.

    Returns
    -------
    ndarray
        The Padé approximant of exp(A)
    """
    N = 0 # numerator
    D = 0 # denominator

    f_p = np.linalg.factorial(p)
    f_q = np.linalg.factorial(q)
    f_p_q = np.linalg.factorial(p+q)

    for i in range(0,p+1):
        N += ((np.linalg.factorial(p+q-i) * f_p) / (f_p_q * np.linalg.factorial(i) * np.linalg.factorial(p-i))) * np.linalg.matrix_power(A,i)
    
    for i in range(0,q+1):
        D += ((np.linalg.factorial(p + q - i) * f_q) / (f_p_q * np.linalg.factorial(i) * np.linalg.factorial(q-i))) * np.linalg.matrix_power(-A,i)
    
    return np.linalg.inv(D) * N

def arnoldi(A, b, m = None):
    """
    Construct orthonormal basis of m-order Krylov subspace generated by images of b under A: span{b, Ab, ..., A^(m-1)b}, represented as orthonormal matrix V, and corresponding upper Hessenberg matrix H such that H = V^T * A * V.

    Parameters
    ----------
    A : ndarray
        n x n.
    b : ndarray
        1 x n, treated as column vector.
    m : int (default None)
        Order of Krylov subspace, will default to n if left blank.

    Returns
    -------
    V : ndarray
        n x m matrix whose columns form an orthonormal basis of the Krylov subspace.
    H : ndarray
        Corresponding m x m upper Hessenberg matrix.
    """
    if m is None:
        m = A.shape[0]

    V = np.zeros((A.shape[0], m), dtype = 'complex_')
    H = np.zeros((m, m), dtype = 'complex_')

    V[:, 0] = b / np.linalg.norm(b, 2)

    for j in range(1, m+1):
        w = np.dot(A, V[:, j-1])

        for i in range(1, j+1):
            H[i-1, j-1] = np.dot(V[:, i-1].conj(), w)
            w = w - H[i-1, j-1]*V[:, i-1]
        
        if (j != m):
            H[j, j-1] = np.linalg.norm(w, 2)
            
            if H[j, j-1] > 1e-12:
                V[:, j] = w / H[j, j-1]
            else:
                return V, H

    return V, H

def lanczos(A, b, m = None):
    if m is None:
        m = A.shape[0]

    V = np.zeros((A.shape[0], m), dtype = 'complex_')
    T = np.zeros((m, m), dtype = 'complex_')

    W = np.zeros((A.shape[0], m), dtype = 'complex_')

    V[:, 0] = b / np.linalg.norm(b) # initialise v0

    w_ = np.dot(A, V[:, 0])
    T[0, 0] = np.dot(w_.conj(), V[:, 0])
    W[:, 0]= w_ - T[0, 0]*V[:, 0]

    for j in range(1, m):
        beta_j = np.linalg.norm(W[:, j-1])
        V[:, j] = W[:, j-1] / beta_j # set columns of V

        w_ = np.dot(A, V[:, j])
        T[j, j] = np.dot(w_.conj(), V[:, j]) # set diagonals
        W[:, j] = T[j, j]*V[:, j] - beta_j*V[:, j-1]

        T[j-1,j] = beta_j # set superdiagonals
        T[j,j-1] = beta_j # set subdiagonals

    return V, T

    # TODO: 
    # remember: lanczos only works with hermitian!
    # implement approximation of exponential with krylov
    # krylov can use padé for exponential of T since T has
    # some nice properties I don't really care about