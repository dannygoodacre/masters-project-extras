from tkinter.ttk import Progressbar
import numpy as np
import krypy as kp
import qutip as qp

def matrix_exp_padé(A, p, q):
    """
    Approximation of matrix exponential of A using (p,q) Padé approximants.

    Parameters
    ----------
    A : array_like
        Square matrix.
    p : int
        Order of numerator of approximant.
    q : int
        Order of denominator of approximant.

    Returns
    -------
    ndarray
        The Padé approximant of exp(A)
    """
    N = 0 # numerator
    D = 0 # denominator

    f_p = np.linalg.factorial(p)
    f_q = np.linalg.factorial(q)
    f_p_q = np.linalg.factorial(p+q)

    for i in range(0,p+1):
        N += ((np.linalg.factorial(p+q-i) * f_p) / (f_p_q * np.linalg.factorial(i) * np.linalg.factorial(p-i))) * np.linalg.matrix_power(A,i)
    
    for i in range(0,q+1):
        D += ((np.linalg.factorial(p + q - i) * f_q) / (f_p_q * np.linalg.factorial(i) * np.linalg.factorial(q-i))) * np.linalg.matrix_power(-A,i)
    
    return np.linalg.inv(D) * N

def arnoldi(A, b, m):
    """
    Construct orthonormal basis of m-order Krylov subspace generated by images of b under A: span{b, Ab, ..., A^(m-1)b}, represented as orthonormal matrix V, and corresponding upper Hessenberg matrix H such that H = V^T * A * V.

    Parameters
    ----------
    A : ndarray
        n x n.
    b : ndarray
        1 x n, treated as column vector.
    m : int
        Order of Krylov subspace.

    Returns
    -------
    V : ndarray
        n x m matrix whose columns form an orthonormal basis of the Krylov subspace.
    H : ndarray
        Corresponding m x m upper Hessenberg matrix.
    """
    V = np.zeros((A.shape[0],m))
    H = np.zeros((m,m))

    V[:,0] = b / np.linalg.norm(b, 2)

    for j in range(1, m+1):
        w = np.dot(A, V[:, j-1])

        for i in range(1,j+1):
            H[i-1, j-1] = np.dot(V[:, i-1].conj(), w)
            w = w - H[i-1, j-1]*V[:, i-1]
        
        if (j != m):
            H[j, j-1] = np.linalg.norm(w,2)
            
            if H[j, j-1] > 1e-12:
                V[:, j] = w / H[j, j-1]
            else:
                return V, H

    return V, H

def lanczos():
    return 0

# TODO:
# create github repository for work in progress
# setup backing up work to github